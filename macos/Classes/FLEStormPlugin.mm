//
//  FLEFlutterPlugin.mm
//  flutter_storm
//
//  Created by David Chavez on 06.11.20.
//

#import "FLEStormPlugin.h"
#include "../StormLib/src/StormLib.h"

#include <unordered_map>
#include <string>

namespace {
NSString *const kChannelName = @"flutter_storm";
NSString *const kFileOpenArchive = @"SFileOpenArchive";
NSString *const kFileCreateArchive = @"SFileCreateArchive";
NSString *const kFileCloseArchive = @"SFileCloseArchive";
NSString *const kFileHasFile = @"SFileHasFile";
NSString *const kFileCreateFile = @"SFileCreateFile";
NSString *const kFileWriteFile = @"SFileWriteFile";
NSString *const kFileCloseFile = @"SFileCloseFile";
NSString *const kFileRemoveFile = @"SFileRemoveFile";
NSString *const kFileRenameFile = @"SFileRenameFile";
NSString *const kFileFinishFile = @"SFileFinishFile";

NSString *const kFileListArchive = @"SFileListArchive";
}

@interface FLEStormPlugin ()
@end

@implementation FLEStormPlugin {
  // The channel used to communicate with Flutter.
  FlutterMethodChannel *_channel;

  // A reference to the registrar holding the NSView used by the plugin. Holding a reference
  // since the view might be nil at the time the plugin is created.
  id<FlutterPluginRegistrar> _registrar;

  // A dictionary to hold all HANDLEs
  std::unordered_map<std::string, HANDLE> handles;
}

+ (void)registerWithRegistrar:(id<FlutterPluginRegistrar>)registrar {
  FlutterMethodChannel *channel = [FlutterMethodChannel methodChannelWithName:kChannelName
                                                              binaryMessenger:registrar.messenger];
    FLEStormPlugin *instance = [[FLEStormPlugin alloc] initWithChannel:channel
                                                                     registrar:registrar];
  [registrar addMethodCallDelegate:instance channel:channel];
}

- (instancetype)initWithChannel:(FlutterMethodChannel *)channel
                      registrar:(id<FlutterPluginRegistrar>)registrar {
  self = [super init];
  if (self) {
    _channel = channel;
    _registrar = registrar;
  }
  return self;
}

/**
 * Handles platform messages generated by the Flutter framework on the platform channel.
 */
- (void)handleMethodCall:(FlutterMethodCall *)call result:(FlutterResult)result {
    id methodResult = nil;

    if ([call.method isEqualToString:kFileOpenArchive]) {
        NSDictionary *args = call.arguments;

        NSString *mpqName = args[@"mpqName"];
        NSNumber *mpqFlags = args[@"mpqFlags"];
        
        HANDLE mpqHandle;
        bool success = SFileOpenArchive([mpqName UTF8String], [mpqFlags unsignedIntValue], 0, &mpqHandle);
        if (success) {
            NSString *uuid = [self generateUUID];
            handles[uuid.UTF8String] = mpqHandle;
            methodResult = uuid;
        } else {
            methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
        }
    } else if ([call.method isEqualToString:kFileCreateArchive]) {
        NSDictionary *args = call.arguments;

        NSString *mpqName = args[@"mpqName"];
        NSNumber *mpqFlags = args[@"mpqFlags"];
        NSNumber *maxFileCount = args[@"maxFileCount"];

        HANDLE mpqHandle;
        bool success = SFileCreateArchive([mpqName UTF8String], [mpqFlags unsignedIntValue], [maxFileCount unsignedIntValue], &mpqHandle);
        if (success) {
            NSString *uuid = [self generateUUID];
            handles[uuid.UTF8String] = mpqHandle;
            methodResult = uuid;
        } else {
            methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
        }
    } else if ([call.method isEqualToString:kFileCloseArchive]) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileCloseArchive(handle);
            if (success) {
                handles.erase([mpqHandle UTF8String]);
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileHasFile]) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileHasFile(handle, [fileName UTF8String]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileCreateFile]) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];
        NSNumber *fileSize = args[@"fileSize"];
        NSNumber *dwFlags = args[@"dwFlags"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            HANDLE fileHandle;
            time_t theTime;
            time(&theTime);
            bool success = SFileCreateFile(handle, [fileName UTF8String], theTime, [fileSize unsignedIntValue], 0, [dwFlags unsignedIntValue], &fileHandle);
            if (success) {
                NSString *uuid = [self generateUUID];
                handles[uuid.UTF8String] = fileHandle;
                methodResult = uuid;
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileWriteFile]) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];
        FlutterStandardTypedData *data = args[@"pvData"];
        NSNumber *dwSize = args[@"dwSize"];
        NSNumber *dwCompression = args[@"dwCompression"];

        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileWriteFile(handle, [[data data] bytes], [dwSize unsignedIntValue], [dwCompression unsignedIntValue]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileCloseFile]) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];

        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileCloseFile(handle);
            if (success) {
                handles.erase([fileHandle UTF8String]);
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileRemoveFile]) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileRemoveFile(handle, [fileName UTF8String], 0);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileRenameFile]) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *oldFileName = args[@"oldFileName"];
        NSString *newFileName = args[@"newFileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileRenameFile(handle, [oldFileName UTF8String], [newFileName UTF8String]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else if ([call.method isEqualToString:kFileFinishFile]) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileFinishFile(handle);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    } else {
        methodResult = FlutterMethodNotImplemented;
    }

    result(methodResult);
}

// MARK: - Helpers

/// Generates a unique UUID that is not already present in lookup table
- (NSString *)generateUUID {
    NSString *uuid = [[NSUUID UUID] UUIDString];
    while (handles.find([uuid UTF8String]) != handles.end()) {
        uuid = [[NSUUID UUID] UUIDString];
    }
    
    return uuid;
}

@end

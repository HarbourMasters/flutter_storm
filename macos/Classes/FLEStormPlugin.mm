//
//  FLEFlutterPlugin.mm
//  flutter_storm
//
//  Created by David Chavez on 06.11.20.
//

#import "FLEStormPlugin.h"
#include "../StormLib/src/StormLib.h"

#include <unordered_map>
#include <string>

namespace {
NSString *const kChannelName = @"flutter_storm";
NSString *const kFileOpenArchive = @"SFileOpenArchive";
NSString *const kFileCreateArchive = @"SFileCreateArchive";
NSString *const kFileCloseArchive = @"SFileCloseArchive";
NSString *const kFileHasFile = @"SFileHasFile";
NSString *const kFileCreateFile = @"SFileCreateFile";
NSString *const kFileWriteFile = @"SFileWriteFile";
NSString *const kFileCloseFile = @"SFileCloseFile";
NSString *const kFileRemoveFile = @"SFileRemoveFile";
NSString *const kFileRenameFile = @"SFileRenameFile";
NSString *const kFileFinishFile = @"SFileFinishFile";
NSString *const kFileFindFirstFile = @"SFileFindFirstFile";
NSString *const kFileFindNextFile = @"SFileFindNextFile";
NSString *const kFileFindClose = @"SFileFindClose";


// Own additions
NSString *const kFileFindCreateDataPointer = @"SFileFindCreateDataPointer";
NSString *const kFileFindGetDataForDataPointer = @"SFileFindGetDataForDataPointer";
}

typedef  NS_ENUM(NSInteger, UUIDGenerationType) {
    UUIDGenerationTypeHandle,
    UUIDGenerationTypeFindData
};

#define METHOD(name) if ([call.method isEqualToString:name])

@interface FLEStormPlugin ()
@end

@implementation FLEStormPlugin {
  // The channel used to communicate with Flutter.
  FlutterMethodChannel *_channel;

  // A reference to the registrar holding the NSView used by the plugin. Holding a reference
  // since the view might be nil at the time the plugin is created.
  id<FlutterPluginRegistrar> _registrar;

  // A dictionary to hold all HANDLE
  std::unordered_map<std::string, HANDLE> handles;

  // A dictionary to hold all SFILE_FOIND_DATA
  std::unordered_map<std::string, SFILE_FIND_DATA> findDataPointers;
}

+ (void)registerWithRegistrar:(id<FlutterPluginRegistrar>)registrar {
  FlutterMethodChannel *channel = [FlutterMethodChannel methodChannelWithName:kChannelName
                                                              binaryMessenger:registrar.messenger];
    FLEStormPlugin *instance = [[FLEStormPlugin alloc] initWithChannel:channel
                                                                     registrar:registrar];
  [registrar addMethodCallDelegate:instance channel:channel];
}

- (instancetype)initWithChannel:(FlutterMethodChannel *)channel
                      registrar:(id<FlutterPluginRegistrar>)registrar {
  self = [super init];
  if (self) {
    _channel = channel;
    _registrar = registrar;
  }
  return self;
}

/**
 * Handles platform messages generated by the Flutter framework on the platform channel.
 */
- (void)handleMethodCall:(FlutterMethodCall *)call result:(FlutterResult)result {
    id methodResult = nil;

    METHOD(kFileOpenArchive) {
        NSDictionary *args = call.arguments;

        NSString *mpqName = args[@"mpqName"];
        NSNumber *mpqFlags = args[@"mpqFlags"];
        
        HANDLE mpqHandle;
        bool success = SFileOpenArchive([mpqName UTF8String], [mpqFlags unsignedIntValue], 0, &mpqHandle);
        if (success) {
            NSString *uuid = [self generateUUIDForType:UUIDGenerationTypeHandle];
            handles[uuid.UTF8String] = mpqHandle;
            methodResult = uuid;
        } else {
            methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
        }
    }

    METHOD(kFileCreateArchive) {
        NSDictionary *args = call.arguments;

        NSString *mpqName = args[@"mpqName"];
        NSNumber *mpqFlags = args[@"mpqFlags"];
        NSNumber *maxFileCount = args[@"maxFileCount"];

        HANDLE mpqHandle;
        bool success = SFileCreateArchive([mpqName UTF8String], [mpqFlags unsignedIntValue], [maxFileCount unsignedIntValue], &mpqHandle);
        if (success) {
            NSString *uuid = [self generateUUIDForType:UUIDGenerationTypeHandle];
            handles[uuid.UTF8String] = mpqHandle;
            methodResult = uuid;
        } else {
            methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
        }
    }

    METHOD(kFileCloseArchive) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileCloseArchive(handle);
            if (success) {
                handles.erase([mpqHandle UTF8String]);
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileHasFile) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileHasFile(handle, [fileName UTF8String]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileCreateFile) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];
        NSNumber *fileSize = args[@"fileSize"];
        NSNumber *dwFlags = args[@"dwFlags"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            HANDLE fileHandle;
            time_t theTime;
            time(&theTime);
            bool success = SFileCreateFile(handle, [fileName UTF8String], theTime, [fileSize unsignedIntValue], 0, [dwFlags unsignedIntValue], &fileHandle);
            if (success) {
                NSString *uuid = [self generateUUIDForType:UUIDGenerationTypeHandle];
                handles[uuid.UTF8String] = fileHandle;
                methodResult = uuid;
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileWriteFile) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];
        FlutterStandardTypedData *data = args[@"pvData"];
        NSNumber *dwSize = args[@"dwSize"];
        NSNumber *dwCompression = args[@"dwCompression"];

        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileWriteFile(handle, [[data data] bytes], [dwSize unsignedIntValue], [dwCompression unsignedIntValue]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileCloseFile) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];

        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileCloseFile(handle);
            if (success) {
                handles.erase([fileHandle UTF8String]);
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileRemoveFile) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *fileName = args[@"fileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileRemoveFile(handle, [fileName UTF8String], 0);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileRenameFile) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *oldFileName = args[@"oldFileName"];
        NSString *newFileName = args[@"newFileName"];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileRenameFile(handle, [oldFileName UTF8String], [newFileName UTF8String]);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileFinishFile) {
        NSDictionary *args = call.arguments;
        NSString *fileHandle = args[@"hFile"];
        HANDLE handle = handles[[fileHandle UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileFinishFile(handle);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileFindFirstFile) {
        NSDictionary *args = call.arguments;
        NSString *mpqHandle = args[@"hMpq"];
        HANDLE handle = handles[[mpqHandle UTF8String]];
        NSString *searchMask = args[@"szMask"];
        NSString *findFileData = args[@"lpFindFileData"];
        SFILE_FIND_DATA *findData = &findDataPointers[[findFileData UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            HANDLE findHandle = SFileFindFirstFile(handle, [searchMask UTF8String], findData, NULL);
            if (findHandle != NULL) {
                NSString *uuid = [self generateUUIDForType:UUIDGenerationTypeHandle];
                handles[uuid.UTF8String] = findHandle;
                methodResult = uuid;
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileFindNextFile) {
        NSDictionary *args = call.arguments;
        NSString *findHandle = args[@"hFind"];
        HANDLE handle = handles[[findHandle UTF8String]];
        NSString *findFileData = args[@"lpFindFileData"];
        SFILE_FIND_DATA *findData = &findDataPointers[[findFileData UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileFindNextFile(handle, findData);
            if (success) {
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    METHOD(kFileFindClose) {
        NSDictionary *args = call.arguments;
        NSString *findHandle = args[@"hFind"];
        HANDLE handle = handles[[findHandle UTF8String]];

        // check if handle is valid
        if (handle == NULL) {
            methodResult = [NSNumber numberWithUnsignedInt:ERROR_INVALID_HANDLE];
        } else {
            bool success = SFileFindClose(handle);
            if (success) {
                handles.erase([findHandle UTF8String]);
                methodResult = [NSNumber numberWithUnsignedInt:ERROR_SUCCESS];
            } else {
                methodResult = [NSNumber numberWithUnsignedInt:GetLastError()];
            }
        }
    }

    // Custom additions
    METHOD(kFileFindCreateDataPointer) {
        SFILE_FIND_DATA findData = {};
        NSString *uuid = [self generateUUIDForType:UUIDGenerationTypeFindData];
        findDataPointers[uuid.UTF8String] = findData;
        methodResult = uuid;
    }

    METHOD(kFileFindGetDataForDataPointer) {
        NSDictionary *args = call.arguments;
        NSString *findFileData = args[@"lpFindFileData"];
        SFILE_FIND_DATA findData = findDataPointers[[findFileData UTF8String]];
        methodResult = [NSString stringWithUTF8String:findData.cFileName];
    }

    if (methodResult == NULL) {
        methodResult = FlutterMethodNotImplemented;
    }

    result(methodResult);
}

// MARK: - Helpers

/// Generates a unique UUID that is not already present in the relevant lookup table
- (NSString *)generateUUIDForType:(UUIDGenerationType)generationType {
    NSString *uuid = [[NSUUID UUID] UUIDString];

    if (generationType == UUIDGenerationTypeHandle) {
        while (handles.find([uuid UTF8String]) != handles.end()) {
            uuid = [[NSUUID UUID] UUIDString];
        }
    } else if (generationType == UUIDGenerationTypeFindData) {
        while (findDataPointers.find([uuid UTF8String]) != findDataPointers.end()) {
            uuid = [[NSUUID UUID] UUIDString];
        }
    }
    
    return uuid;
}

@end
